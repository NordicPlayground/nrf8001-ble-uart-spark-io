// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statementhttps://build.particle.io/build/56eaea97bd9cf0716b00065e#flash was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

// This #include statement was automatically added by the Particle IDE.
#include "nrf8001-ble-uart-spark-io/nrf8001-ble-uart-spark-io.h"

/* Copyright (c) 2014, Nordic Semiconductor ASA
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// send commands with
// curl https://api.spark.io/v1/devices/[ID]/set_val -d access_token=[token] -d "args=11"

#include "nrf8001-ble-uart-spark-io/lib_aci.h"
#include "nrf8001-ble-uart-spark-io/boards.h"

#include "nrf8001-ble-uart-spark-io/rbc_mesh_interface.h"
#include "nrf8001-ble-uart-spark-io/serial_evt.h"

#define ACCESS_ADDR     (0xA541A68F)
//#define ACCESS_ADDR     (e4cf98b0bd299b9ac1e84091626157a9fd6f0002)

// defining the state of the system for communication
enum state_t{
    init,           // not yet initialized
    ready,          // no external command in work
    waitingForEvent // external command in work, waiting for answer from SPI slave
};

int state = init;

int state_test = 100;

// buffer for the last value send by the SPI slave
int lastResponse;
int temp;
int flow_speed;
int gas;

int initState = 0;

// callback function for http command to set a handle value
int set_val(String args){

    if(state != ready){
        Serial.println("STATE not ready");
        Serial.println(state);
        Serial.println(digitalRead(A2));
        Serial.println(digitalRead(D5));
        Serial.println(digitalRead(D2));
        return -5;
    }
    state = waitingForEvent;

    //uint8_t handle = args[0] - '0';
    uint8_t handle_hi = args[0] - '0';
    uint8_t handle_lo = args[1] - '0';
    uint16_t handle = (handle_hi *10 + handle_lo);
    Serial.println("handle: ");
    Serial.print(handle);
    //uint8_t value = 0;
    uint8_t value  = args[2] - '0';
    //uint8_t value = args.toInt();

   // Serial.printlnf("%p", &value);

    return rbc_mesh_value_set(handle, &value, (uint8_t) 1);
}

/*int get_val(String args){

    if(state != ready){
        return -1;
    }
    state = waitingForEvent;

    uint8_t handle_hi = args[0] - '0';
    uint8_t handle_lo = args[1] - '0';
    uint16_t handle = (handle_hi * 10 + handle_lo);
    
    return rbc_mesh_value_get(handle);
}*/

// callback function for http command to get a handle value
int get_val(String args){
    
    //Serial.println("getting value");

    if(state != ready){
        Serial.println("State is NOT ready!");
        return -1;
    }
    state = waitingForEvent;

    uint8_t handle_hi = args[0] - '0';
    uint8_t handle_lo = args[1] - '0';
    uint16_t ping_handle = 32 + (handle_hi * 10 + handle_lo);
    uint16_t handle = (handle_hi * 10 + handle_lo);
    
    uint8_t buffer_ = 1;

    rbc_mesh_value_set(ping_handle, &buffer_, 1);

    //wait for value to be refreshed
    serial_evt_t evnt;
    /*while(!rbc_mesh_evt_get(&evnt)){ 
        Serial.print(".");
        delay(200);
        }*/ //wait for confirmation of refreshed value
    do {
         rbc_mesh_evt_get(&evnt);
         Serial.print("-");
    }
    while(((evnt.opcode != 0xB3) && (evnt.opcode != 0xB4)) || (evnt.params.event_update.handle != handle) || (evnt.params.event_new.handle != handle));
    
    Serial.println("GOT OUT OF FIRST WHILE LOOP!");
    //rbc_mesh_evt_get(&evnt);
    delay(200); //allow time for handle cache to update
    rbc_mesh_value_get(handle);
    
        do {
         rbc_mesh_evt_get(&evnt);
         Serial.print(".");
    }
    while(evnt.params.cmd_rsp.command_opcode != 0x7A);
    
    Serial.print("HANDLE IS: ");
    Serial.println(handle);
    Serial.print("PING HANDLE IS: ");
    Serial.println(ping_handle);
    
    Serial.print("EVENT OPCODE: ");
    Serial.println(evnt.opcode, HEX);
    
    Serial.print("VAL_GET.DATA: ");
    Serial.println(evnt.params.cmd_rsp.response.val_get.data[0]);
    
    Serial.print("CMD_RESPONSE_OPCODE: ");
    Serial.println(evnt.params.cmd_rsp.command_opcode, HEX);
    
    if (ping_handle == 37) {
        gas = evnt.params.cmd_rsp.response.val_get.data[0];
    }
    else if(ping_handle == 38) {
        temp = evnt.params.cmd_rsp.response.val_get.data[0];
    }
    else if(ping_handle == 35) {
        flow_speed = evnt.params.cmd_rsp.response.val_get.data[0];
    }
    
    state = ready;
    
    
    //lastResponse = evnt.params.cmd_rsp.response.val_get.data[0];
    //return evnt.params.cmd_rsp.response.val_get.data[0];
    return 0;
}

aci_pins_t pins;

// arduino conform init function
void setup(void)
{
  Serial.begin(9600);

  //Serial.println("Setup");
  //Particle.publish("SETUP");

  pins.board_name = BOARD_DEFAULT; //See board.h for details REDBEARLAB_SHIELD_V1_1 or BOARD_DEFAULT
  pins.reqn_pin   = A2;
  pins.rdyn_pin   = D5;
  pins.mosi_pin   = A5;
  pins.miso_pin   = A4;
  pins.sck_pin    = A3;

  pins.spi_clock_divider      = SPI_CLOCK_DIV64; //SPI_CLOCK_DIV8  = 8MHz SPI speed
                                                 //SPI_CLOCK_DIV16 = 4MHz SPI speed
                                                 //SPI_CLOCK_DIV64 = 1MHz SPI speed

  pins.reset_pin              = D2;
  pins.active_pin             = NRF_UNUSED;
  pins.optional_chip_sel_pin  = NRF_UNUSED;

  pins.interface_is_interrupt = false; //Interrupts still not available in Chipkit
  pins.interrupt_number       = 1;

  rbc_mesh_hw_init(&pins);

  Spark.function("set_val", set_val);
  Spark.function("get_val", get_val);
  Spark.variable("state", &state, INT);
  Spark.variable("temp", &temp, INT);
  Spark.variable("gas", &gas, INT);
  Spark.variable("flow_speed", &flow_speed, INT);
  Spark.variable("lastResponse", &lastResponse, INT);

  Serial.println("SETUP DONE");

  return;
}

// sending intialization commands to SPI slave
// alternating sending of commands and waiting for response
void initConnectionSlowly(){
    switch(initState) {
        case 0:
            state_test = rbc_mesh_init(ACCESS_ADDR, (uint8_t) 38, (uint32_t) 100);
            initState++;
            Serial.println("Sent init command");
            Spark.publish("Sent init command");
            break;
/*        case 1:
            rbc_mesh_value_enable((uint8_t) 5);
            //rbc_mesh_value_enable((uint8_t) 5);
            //rbc_mesh_value_enable((uint8_t) 6);
            initState++;
            Serial.println("Enabled value 1");
            Spark.publish("Enabled value 1");
            break;
        case 2:
            rbc_mesh_value_enable((uint8_t) 6);
            initState++;
            Serial.println("Enabled value 2");
            break;*/
        case 65:
            state = ready;
            Serial.println("init done");
            break;
        default:
            rbc_mesh_value_enable((uint8_t) initState - 1);
            Serial.print("Enabled value: ");
            Serial.println(initState);
            initState++;
            break;
    }
}

// arduino conform main loop
void loop() {
    //Particle.publish("HERE");
    static bool newMessage = false;

    // send next initialization command to SPI slave until we leave init state
    if (state == init && newMessage) {
        //Serial.println("here");
        Particle.publish("New Message");
        initConnectionSlowly();
    }

    //Process any ACI commands or events
    serial_evt_t evnt;
    newMessage = rbc_mesh_evt_get(&evnt);
    delay(100);

    if(newMessage) {
        Serial.println("there is a new message");
        Serial.print("Event: ");
        Serial.println(evnt.opcode, HEX);
    }

    if(newMessage && evnt.opcode == SERIAL_EVT_OPCODE_CMD_RSP){
        if (evnt.params.cmd_rsp.status != ACI_STATUS_SUCCESS)
        {
            Serial.print("Error response on cmd ");
            //Serial.print(evnt.params.cmd_rsp.command_opcode);
            Serial.print(evnt.params.cmd_rsp.command_opcode, HEX);
            Serial.print(": ");
            Serial.print(evnt.params.cmd_rsp.status, HEX);
            //Serial.print(evnt.params.cmd_rsp.status);
            Serial.println();
            Serial.println(digitalRead(A2));
            Serial.println(digitalRead(D5));
            Serial.println(digitalRead(D2));
            Serial.println();
        }
        
        if (state == waitingForEvent) {
            Serial.println("Waiting");
            state = ready;
            
            //lastResponse = evnt.params.cmd_rsp.response.val_get.data[0];
        }
    }
    
    
}
